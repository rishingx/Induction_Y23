# Solutions to Exercise Session 1

Source:   https://rsl.ethz.ch/education-students/lectures/ros.html 

# Assumptions

The only two assumptions are that the system has docker installed and running on a X display server.

# Setting up the environment

Here we will download the ROS docker image, and make sure it is running properly. We will also configure a ROS container to our liking and create a custom image from this container. This new image will be our base going forward.

1. Pulling the ROS image

We will dowload the official ROS image - noetic distribution.

``` bash
docker pull ros:noetic-robot
docker run ros:noetic-robot
```

If the above command works, we can now `exit` this container. We will spin up a new one for our configuration.

2. Forwarding the display ports

We will test various GUI applications inside our container (the *turtlesim* and *gazebo* packages), which require forwarding the calls to X server inside the container to the X server of our host machine.

``` bash
xhost +local:docker
```

Our `docker run` command also needs to be modified.

``` bash
docker run --name custom_ros -it -e DISPLAY=$DISPLAY -v /tmp/.X11-unix/:/tmp/.X11-unix/ ros:noetic-robot bash
```

It should drop us inside a bash terminal within a `ros:noetic-robot` container named `custom_ros`. We can now start configuring our container.

3. Authenticating our X display ports

On the host machine type:

``` bash
xauth list
```

One entry of the output should be of the format: `<hostname-of-machine>/unix:<no-of-display> MIT-MAGIC-COOKIE-1 <some-number-here>`.
We need to copy the: `<some-number-here>` part.

Next, in the docker container, we need to add a corresponding entry to the code we copied.

``` bash
touch ~/.Xauthority
xauth add :0 MIT-MAGIC-COOKIE-1 <some-number-here>
```

Source: https://stackoverflow.com/questions/44429394/x11-forwarding-of-a-gui-app-running-in-docker

4. Setting up the ROS container

Once inside our container, we will install a few example ROS tutorials, and run them to test out our container.

``` bash
sudo apt-get update
sudo apt-get install ros-noetic-ros-tutorials
```

Next, we will source the ROS environment. The official docs encourage using the `ros_entrypoint.sh` script. However, this leads to an annoying bug where running a *bad* command immediately quits the container.

Instead we will directly source the requried file. The `ros_entrypoint.sh` script also does this but, indirectly.

``` bash
source /opt/ros/noetic/setup.bash
```

We will also add it to our bashrc so that we don't have to repeat this commad every time we start our container.

``` bash
echo "source /opt/ros/noetic/setup.bash" >> ~/.bashrc
```

5. Testing turtle simulator

To run the ROS master node, enter the following command.

``` bash
roscore
```

On another terminal window, type

``` bash
docker exec -it custom_ros bash
```

to create another bash session in the already running container `custom_ros`. Once in, we can run a turtle node, after sourcing our setup.

``` bash
source /opt/ros/noetic/setup.bash
rosrun turtlesim turtlesim_node
```

This should open a blue window containing a turtle icon in the middle. It means the display forwards, as well as the ROS container, both are working fine. At this point, we can also go ahead and test the talker-listner nodes as outlined in Lecture 1.

6. Creating a ROS Workspace

We will create a workspace for the catkin build system.

``` bash
mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/
catkin_make
```

Next we will source the setup file generated by catkin, and also add it to our bashrc.

``` bash
source devel/setup.bash
echo "source ~/catkin_ws/devel/setup.bash" >> ~/.bashrc
```

7. Setting up git can catkin tools

We will now install two useful and essential tools

``` bash
sudo apt update
sudo apt install git
sudo apt install python3-catkin-tools
```

Once these are installed, our setup is complete and we can go ahead with the Lecture 1 up until Gazebo Simulator.
However, the Lecture prefers `catkin build` over `catkin_make`. So to avoid conflicts, we will need to remove the already made `build` and `devel` spaces.

``` bash
cd ~/catkin_ws/
rm -rf build
rm -rf devel
```

While building the `ros_package_template` or any other future package, we might run into missing dependencies. These can be checked beforehand too.

``` bash
rosdep check --from-paths ~/catkin_ws/src --ignore-src
```

8. Future use

Stopping the container, after `exit`.

``` bash
docker stop custom_ros
```

Restarting and entering into a bash session.

``` bash
docker start custom_ros
docker exec -it custom_ros bash
```

# Solving the exercise

1. Setting up the SMB simulation

Before we begin the SMB simulation, we need to download the set of packages `smb_common`. We can do this by downloading it on the host machine, extracting and copying it into the container.

Once we have downloaded and extracted `smb_common.zip`, we can copy the folder `smb_common` into `custom_ros:/root/git` using the following.

``` bash
docker cp /path/to/smb_common custom_ros:/root/git/.
```

Next we create our workspace inside the container and create a symlink using,

``` bash
cd
mkdir ~/Workspaces/smb_ws/src
ln -s ~/git/smb_common/ ~/Workspaces/smb_ws/src/
```

Now, we can install the dependencies that `rosdep` finds using,

``` bash
rosdep check --from-paths ~/Workspaces/smb_ws/src --ignore-src
```

Unfortunate, in my case it could not find a package, leading to build errors down the line. I installed it using,

``` bash
sudo apt install ros-noetic-gazebo-plugins
```

Once all the dependencies are installed, we can go ahead and compile the `smb_gazebo` package using,

``` bash
cd ~/Workspaces/smb_ws/
catkin build smb_gazebo
source devel/setup.bash
```

2. Launching the simulation

We can now go ahead and launch the simulation.

``` bash
roslaunch smb_gazebo smb_gazebo.launch
```

As of now, this does NOT show the GUI, due to some error in libGL. Working on it.
However, the rest of the process behaves as expected, giving us the necessary rostopics & rosnodes.

3. Setting a velocity

We can get a list of nodes related to velocity using,

``` bash
rostopic list | grep "vel"
```

Among the ones listed, `cmd_vel` seems to be the relevant one.
We can get it's type using,

``` bash
rostopic type /cmd_vel
```

Which tells us that the type is `geometry_msgs/Twist`, the format of which is

```
Vector3 linear
    float64 x
    float64 y
    float64 z

Vector3 angular
    float64 x
    float64 y
    float64 z
```

We can now provide a custom velocity to our robot using,

``` bash
rostopic pub /cmd_vel geometry_msgs/Twist "linear:
    x: 1.0
    y: 2.0
	z: 3.0
angular:
    x: 1.0
    y: 2.0
    z: 3.0"
```

Note: Simply using tab completion after `geometry_msgs/Twist` gives us the format directly.
Source: https://docs.ros.org/en/diamondback/api/geometry_msgs/html/msg/Twist.html

4. Controlling the robot using keyboard
5. Writing a custom launch file
